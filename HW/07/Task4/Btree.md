Выбрать один из 6 типов реализации индексов в PostgreSQL, написать краткую выжимку о механизме работы (не больше листа A4).

---

Нижеследующий рассказ про B-деревья — это кратенькая выжимка отсюда https://habr.com/company/postgrespro/blog/330544/.

Итак, B-деревья удобны для данных, которые можно отсортировать (определены операторы $>$, $\geq$, $<$, $\leq$, $=$). При этом можно и свои типы данных использовать.

Избранные свойства индекса B-tree:

* возвращает упорядоченные данные
* в случае нескольких колонок данные внутри страниц индекса (о которых будет позже) будут отсортированы сначала по первому полю, затем по второму и далее
* индексирует неопределенные значения
* позволяет указать порядок сортировки значений при создании индекса (`can_order`) — [пока единственный](https://habr.com/company/postgrespro/blog/326106/) из индексов PostgreSQL 
* поддерживает ограничения уникальности и первичного ключа (`can_unique`) — тоже [пока единственный](https://habr.com/company/postgrespro/blog/326106/) из индексов
* поддерживает оба способа получения значений: и индексное сканирование (`index_scan `), и сканирование битовой карты (`bitmap_scan`)
* может выдавать результаты запроса в порядке, обратном указанному при создании индекса (`backward_scan`)
* дешевле сначала заполнять таблицу данными, а потом создавать индекс, чем наоборот 

Индексные записи в B-дереве объединены в страницы, в листовых страницах содержаться ссылки на строки таблицы (TID). B-деревья

- сбалансированы (одинаковое расстояние от любой листовой страницы до корневой)
- данные в них упорядочены — по неубыванию (by default) — и между страницами, и внутри каждой страницы
- страницы одного уровня связаны, представляют двунаправленный список

При поиске в таком индексе интересующий ключ сравнивается с с ключами в вершинах, и благодаря упорядоченности ключей в страницах можно спуститься к нужной листовой, далее могут ещё перебираться соседние листья (ключи в страницах одного уровня тоже упорядочены).